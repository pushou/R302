
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.5.34" name="generator"/>
<title>Mplsmm - BUT R302 Réseaux d'opérateurs</title>
<link href="../assets/stylesheets/main.35f28582.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<script src="../js/unpkg.com/d3@7.js" type="text/javascript"></script><script src="../js/unpkg.com/markmap-lib@0.15.4.js" type="text/javascript"></script><script src="../js/unpkg.com/markmap-view@0.15.4.js" type="text/javascript"></script><style type="text/css">div.mkdocs-markmap {
    width: 100%;
    min-height: 1em;
    border: 1px solid grey;
}
.mkdocs-markmap > svg {
    width: 100%;
    height: 100%;
    display: block;
}
</style></head>
<body dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="BUT R302 Réseaux d'opérateurs" class="md-header__button md-logo" data-md-component="logo" href=".." title="BUT R302 Réseaux d'opérateurs">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            BUT R302 Réseaux d'opérateurs
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Mplsmm
            
          </span>
</div>
</div>
</div>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="BUT R302 Réseaux d'opérateurs" class="md-nav__button md-logo" data-md-component="logo" href=".." title="BUT R302 Réseaux d'opérateurs">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg>
</a>
    BUT R302 Réseaux d'opérateurs
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    Généralités BGP (texte)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../bgpmindmap.html">
<span class="md-ellipsis">
    Généralités BGP (mindmap)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../bgp_attrs.html">
<span class="md-ellipsis">
    Attributs BGP (mindmap)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../bgp_attrs/">
<span class="md-ellipsis">
    Attributs BGP (texte)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../bgp_cmd.html">
<span class="md-ellipsis">
    Commandes BGP (mindmap)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../commandes_aplat.mm/">
<span class="md-ellipsis">
    Commandes BGP (texte)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../mplgeneralite.html">
<span class="md-ellipsis">
    Généralités MPLS (mindmap)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../mpls_aplat.mm/">
<span class="md-ellipsis">
    Généralités MPLS (texte)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../mpls_cmd.html">
<span class="md-ellipsis">
    Commandes MPLS (mindmap)
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../mpls_cmd_aplat.mm/">
<span class="md-ellipsis">
    Commandes MPLS (texte)
  </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>Mplsmm</h1>
<p>Généralités MPLS</p>
<div class="mkdocs-markmap"><markmap-data class="language-markmap" hidden="true">---

markmap:

  colorFreezeLevel: 2

  maxWidth: 700

---



# MPLS



## Caractéristiques et intérêts



- MPLS permet de faire du "Traffic engineering" (partage de charge, de la QoS, du VPN.)

- Le réseau MPLS est opéré par une seule entité. Seul le passage au  SDN (Software Defined Networking) permet de piloter plusieurs fournisseurs de réseaux afin choisir le meilleur chemin.





## Les VRF sont nécessaires pour MPLS



 - Un routeur physique peut gérer plusieurs tables de routages : en général une par client. Ce sont les VRF (Virtual Routing &amp; Forwarding).

 - Chaque VRF correspond à une table de routage (une pour chaque client du FAI). 

 - Les VRF permettent à plusieurs clients d'utiliser le même plan d'adressage privé sans craindre l'"overlaps" des réseaux. 

 - Les "VRF lite" sont des VRF sans MPLS. Elles sont utiles sur des réseaux de petites à moyennes tailles.



## Définitions 



- MPLS c'est de la commutation de paquets pas du parcours des tables de routage pour trouver le meilleur chemin.

- Technologie de couche entre 2 et 3 (2,5).

- Basée sur la labellisation: une étiquette est ajoutée au paquet.

- Le paquet et transmis par le routeur suivant en fonction de ce label qui lui-même en appose un. En conséquence un label a une signification locale et on peut donc avoir un label apparaissant plusieurs fois.

- MPLS transporte de l'IP, de l'Ethernet ou de l'ATM de façon agnostique dans un circuit virtuel (VC).





## Description des en-têtes des paquets MPLS



- 012345678901234567890123456789  

 |-------LABEL---------|TC|S|TTL|

  Label : 20 premiers bits sont des entiers courts

  TC : 3 bits utilisés pour la QoS

  Stack : indique la fin de l'empilement



## Les différents types de routeurs MPLS



- **LER (Label Edge Router)** : ce sont les points d'entrée (ingress) et de sortie (egress) du réseau MPLS. l'ingress LER reçoit le paquet, détermine son étiquette. À la sortie du réseau l'egress LER enlève les labels. Ils effectuent des opérations complexes.

- **LSR (Label Switch Router)** ou "transit node" : Routeur commutateur de labels MPLS. 

  - Chaque LSR possède une table de label propre.

  - Chaque LSR assigne des labels à ses FEC.

  - Les labels sont assignés et échangés entre LSR adjacents.

  - Le VPN et l'ingénierie de trafic nécessitent des échanges de labels entre voisins distants.

- Les LER sont aussi appelés PE (Provider Edge) et les LSR des P (Provider) dans la terminologie Cisco. Les CE (Customer Edge) sont les routeurs des clients en frontal des LER ou PE.

- Terminologie Cisco

  CE -&gt; PE  →P  P ... →E -&gt; CE

  avec la terminologie Officielle

  CE -&gt; ingress LER -&gt; LSR - LSR -egress LER -&gt; CE



## FEC ou classe d'équivalence



- FEC ("Forwarding Equivalent Class" ou "Classe d'équivalence") : on réunit les paquets ayant les mêmes caractéristiques (IP|source ou IP|réseau de destination ou autres...) dans une même FEC. Une FEC est souvent identifiée par le réseau de destination.

- Les couples de labels sortants et rentrants matérialisent pour chaque FEC un chemin ou **circuit virtuel** des paquets. C'est le LSP (**Label Switching Path**). Il y a un LSP différent pour l'aller et pour le retour.

- Une FEC peut être travaillée manuellement en fonction de critères plus précis (ports , adresse sources...) pour différencier certains flux, par exemple pour la QoS. En mode automatique il faut que l'ensemble des LSR échangent les labels.



## Traffic Engineering



- Le "traffic engineering" permet d'avoir des contraintes additionnelles sur le meilleur chemin (par exemple pour avoir le plus court chemin **et** avec la meilleure bande passante).

- Le protocole RSVP permet de réserver de la bande passante.

- Chaque chemin de commutation de label (Label Switching Path) peut être associé à une réservation de bande passante. Cette réservation peut être calculée de façon automatique ("auto bandwidth").

- "MPLS Fast Reroute" améliore la convergence lors d'un incident. MPLS-FR a pour but de pré-calculer des LSP de secours et pré-implémenter la FIB pour gagner du temps.





## Dynamique du "switching MPLS"



  1. Le paquet entre sur le réseau.

  2. Le LER détermine une FEC pour le paquet et appose une étiquette contenant un label de sortie (opération **PUSH**).

  3. Le LER transmet le paquet au LSR.

  4. Le LSR modifie l'étiquette (opération **SWAP**) : le Label de sortie devient le label d'entrée et un nouveau label de sortie est apposé.

  5. Le paquet est transmis de LER en LER avec plusieurs **swap**.

  6. Le paquet arrive au LSR de sortie qui dépile l'étiquette (opération **POP**) et transmet le paquet IP qui y était contenu au réseau du client.





## LDP: Protocole de Distribution de Labels



- LDP transporte les informations nécessaires à la construction des tables de labels sur les LSR.

- Les LSR connaissent les autres routeurs grâce à un IGP.



## Le modèle VPN MPLS 





- Les VPN MPLS sont de niveau 2 (Layer 2 Pseudowire) ou 3 (L3VPN).

- Le "MultiProtocol BGP" (MP-BGP) est une extension au protocole de routage BGP qui permet à différentes familles d’adresses d’être distribuées en parallèle entre routeurs (en l'occurrence pour les L3VPN : adresses VPN IPv4/v6 avec labels MPLS). Les routeurs d'un réseau MPLS communiquent ainsi en i-MP-BGP (interior MultiProtocol BGP). 

- Les PE et CE échangent des informations au travers de protocoles comme BGP, OSPF ou des routes statiques. Ils reçoivent des annonces de routes.





## Route Distinguisher et Route Target (source wikipédia)



- Une VRF a un "**Route Distinguisher**" unique. Le format de RD est souvent "Numéro de l'AS :Numéro Assigné". Le numéro assigné dépend de l'opérateur:

    -  Exemple pour le VRF client_A :

    IP VRF client_A rd 65535:1

    - Le préfixe suivant : 192.168.0.0 de la VRF client_A prendra alors cette forme :

    65535:1:192.168.0.0

- Le **route target (RT)** est une information supplémentaire associée à tout préfixe d'une VRF lors de son export vers BGP. Cette valeur peut être égale au RD (route distinguisher) ou pas. Elle est utilisée pour distinguer et filtrer les préfixes reçus en MP-BGP afin de déterminer vers quelles VRF locales ils doivent être importés. Du point de vue BGP il s'agit d'une communauté BGP étendue (64 bits). Un préfixe peut recevoir un ou plusieurs RT. 



## MPLS et traceroute



- La décrémentation du TTL n'est pas demandée lors de la traversée d'un routeur par MPLS  ce qui est problématique pour faire un traceroute ... et donc voir le chemin emprunté par les paquets afin de diagnostiquer d'éventuels problèmes.

- On peut néanmoins l'implémenter et faire du traceroute avec un réseau MPLS.



## La sécurité avec MPLS



- La sécurité du réseau MPLS repose sur :

  - L'indépendance des flux.

  - Le pilotage et la sécurité du réseau qui sont assurées par un seul fournisseur. 

- On peut néanmoins s'interroger sur le chiffrement des données qui est absent de MPLS et sur le fait que c'est le niveau de sécurité du fournisseur qui détermine le niveau de sécurité du réseau.


</markmap-data></div>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
<script src="../assets/javascripts/bundle.56dfad97.min.js"></script>
<script type="text/javascript">(function initializeMarkmap() {
    const transformer = new markmap.Transformer();
    const assets = transformer.getAssets();
    const loading = Promise.all([
        assets.styles && markmap.loadCSS(assets.styles),
        assets.scripts && markmap.loadJS(assets.scripts),
    ]);

    function parseData(content) {
        const { root, frontmatter } = transformer.transform(content);
        let options = markmap.deriveOptions(frontmatter?.markmap);
        options = Object.assign({
            fitRatio: 0.85,
        }, options);
        return { root, options };
    }

    function resetMarkmap(m, el) {
        const { minX, maxX, minY, maxY } = m.state;
        const height = el.clientWidth * (maxX - minX) / (maxY - minY);
        el.style.height = height + "px";
        m.fit();
    }

    function renderMarkmap(el) {
        let svg = el.querySelector('svg');
        if (svg) return;
        const content = el.textContent;
        el.innerHTML = '<svg>';
        svg = el.firstChild;
        const { root, options } = parseData(content);
        const m = markmap.Markmap.create(svg, options, root);
        resetMarkmap(m, el);
        transformer.hooks.retransform.tap(() => {
            const { root, options } = parseData(content);
            m.setData(root, options);
            resetMarkmap(m, el);
        });
    }

    function updateMarkmaps(node) {
        for (const el of node.querySelectorAll('.mkdocs-markmap')) {
            renderMarkmap(el);
        }
    }

    loading.then(() => {
        const observer = new MutationObserver((mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        updateMarkmaps(node);
                    }
                }
            }
        });

        observer.observe(document.body, { childList: true });

        updateMarkmaps(document);
    });
})();
</script></body>
</html>